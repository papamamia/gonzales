<?xml version="1.0" encoding="UTF-8" ?>
<Module>
<Content type="html"><![CDATA[

<!DOCTYPE html>


<!-- Ultimate Game Stash file--> 
<!-- For the regularly updating doc go to https://docs.google.com/document/d/1_FmH3BlSBQI7FGgAQL59-ZPe8eCxs35wel6JUyVaG8Q/ -->



<html lang="en-us">
  <head>
<base href="https://cdn.jsdelivr.net/gh/bubbls/UGS-Assets@main/10minutestilldawn/">

    <script async src="https://www.googletagmanager.com/gtag/js?id=G-7FN7LEVWXD"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'G-7FN7LEVWXD');
    </script>

    <title>10 Minutes Till Dawn | Seraph</title>
    <link rel="shortcut icon" href="../../images/ico.ico" type="image/x-icon">
    <script src="../../storage/js/cloak.js"></script>

    <meta charset="utf-8" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <script src="Build/UnityLoader.js"></script>
  <script>
    function mergeFiles(fileParts) {
      return new Promise((resolve, reject) => {
        let buffers = [];
        function fetchPart(i) {
          if (i >= fileParts.length) {
            let mergedBlob = new Blob(buffers);
            resolve(mergedBlob);
            return;
          }
          fetch(fileParts[i])
            .then(r => r.arrayBuffer())
            .then(data => {
              buffers.push(data);
              fetchPart(i + 1);
            })
            .catch(reject);
        }
        fetchPart(0);
      });
    }

    function getParts(file, start, end) {
      let arr = [];
      for (let i = start; i <= end; i++) {
        arr.push(file + ".part" + i);
      }
      return arr;
    }

    function resizeUnityContainer() {
      var container = document.getElementById("gameContainer");
      if (container) {
        container.style.width = window.innerWidth + "px";
        container.style.height = window.innerHeight + "px";
      }
    }

    window.addEventListener('resize', resizeUnityContainer);

    function UnityProgress(gameInstance, progress) {
      try {
        if (progress === 'complete') {
          return;
        }
        var pct = 0;
        if (typeof progress === 'number') pct = progress;
        else if (progress && progress.total && progress.loaded) pct = progress.loaded / progress.total;
        var txt = document.getElementById('loading-text');
        if (txt) txt.textContent = 'Loading... ' + Math.round(pct * 100) + '%';
      } catch (e) {
        console.error('Progress error:', e);
      }
    }

    window.addEventListener("load", function () {
      window.unityMergedFiles = {};

      Promise.all([
        mergeFiles(getParts("Build/10MinutesTillDawnWebGL.data.unityweb", 1, 2)),
        mergeFiles(getParts("Build/10MinutesTillDawnWebGL.wasm.code.unityweb", 1, 2)),
        mergeFiles(getParts("Build/10MinutesTillDawnWebGL.wasm.framework.unityweb", 1, 1))
      ]).then(([dataBlob, wasmCodeBlob, wasmFrameworkBlob]) => {
        window.unityMergedFiles['Build/10MinutesTillDawnWebGL.data.unityweb'] = URL.createObjectURL(dataBlob);
        window.unityMergedFiles['Build/10MinutesTillDawnWebGL.wasm.code.unityweb'] = URL.createObjectURL(wasmCodeBlob);
        window.unityMergedFiles['Build/10MinutesTillDawnWebGL.wasm.framework.unityweb'] = URL.createObjectURL(wasmFrameworkBlob);

        console.log("Merged files ready:", Object.keys(window.unityMergedFiles));

        function findMergedKey(requestUrl) {
          try {
            if (typeof requestUrl !== 'string') return null;
            if (window.unityMergedFiles[requestUrl]) return requestUrl;
            var resolved = new URL(requestUrl, window.location.href).pathname.replace(/^[\\/]+/, '');
            if (window.unityMergedFiles[resolved]) return resolved;
            var withBuild = 'Build/' + resolved.split('/').pop();
            if (window.unityMergedFiles[withBuild]) return withBuild;
          } catch (e) {
          }
          return null;
        }

        const originalFetch = window.fetch.bind(window);
        window.fetch = function(url, ...args) {
          const key = findMergedKey(url);
          if (key) {
            console.log("Redirecting fetch to merged file:", key, "->", window.unityMergedFiles[key]);
            return originalFetch(window.unityMergedFiles[key], ...args);
          }
          return originalFetch(url, ...args);
        };

        const OriginalXHR = window.XMLHttpRequest;
        window.XMLHttpRequest = function() {
          const xhr = new OriginalXHR();
          const originalOpen = xhr.open;
          xhr.open = function(method, url, ...args) {
            try {
              const key = findMergedKey(url);
              if (key) {
                console.log("Redirecting XHR to merged file:", key);
                return originalOpen.call(this, method, window.unityMergedFiles[key], ...args);
              }
            } catch (e) {
            }
            return originalOpen.call(this, method, url, ...args);
          };
          return xhr;
        };

        window.gameInstance = UnityLoader.instantiate("gameContainer", "Build/10MinutesTillDawnWebGL.json", {
          onProgress: UnityProgress,
          Module: {
            onRuntimeInitialized: function () {
              resizeUnityContainer();
              let loadingText = document.querySelector("#loading-text");
              if (loadingText) loadingText.remove();
              UnityProgress(window.gameInstance, 'complete');
            }
          }
        });
      })
      .catch(err => {
        console.error("Unity load failed:", err);
        let txt = document.getElementById('loading-text');
        if (txt) txt.textContent = 'Loading failed: ' + (err && err.message ? err.message : err);
      });
    });
  </script>
    <style>
      html,
      body {
    background: #000;
        width: 100%;
        height: 100%;
        overflow: visible;
        padding: 0;
        margin: 0;
      }

      div#gameContainer {
        background: transparent !important;
        position: absolute;
      }

      div#gameContainer canvas {
        position: absolute;
      }

      div#gameContainer[data-pixelated="true"] canvas {
        image-rendering: optimizeSpeed;
        image-rendering: -webkit-crisp-edges;
        image-rendering: -moz-crisp-edges;
        image-rendering: -o-crisp-edges;
        image-rendering: crisp-edges;
        image-rendering: -webkit-optimize-contrast;
        image-rendering: optimize-contrast;
        image-rendering: pixelated;
        -ms-interpolation-mode: nearest-neighbor;
      }
    </style>
  </head>

    <div id="gameContainer" data-pixelated="true"></div>

    <!-- Sticky Bottom Center Ad (728x90) with Smooth Slide-Out and Reappearance -->
<style>
  /* Container: Bottom center, fixed, with overflow hidden */
  #ad-container {
    position: fixed;
    bottom: 0;
    left: 50%;
    transform: translateX(-50%);
    width: min(728px, calc(100% - 20px)); /* 728px, 10px margin on mobile */
    height: 90px;
    background: rgba(0, 0, 0, 0.90);
    display: none;
    z-index: 99999;
    border-radius: 0; /* Sharp corners */
    overflow: hidden;
    box-shadow: 0 -2px 12px rgba(0, 0, 0, 0.45);
    box-sizing: border-box;
    transition: transform 0.5s ease-in-out; /* Smooth slide-in/out animation */
  }

  /* Slide-out animation */
  #ad-container.hidden {
    transform: translate(-50%, 100%); /* Slide down out of view */
  }

  #ad-iframe {
    position: absolute;
    top: 0;
    left: 50%;
    transform: translateX(-50%);
    width: 745px; /* Updated width */
    height: 90px; /* Updated height */
    border: 0;
    display: block;
    overflow: hidden;
    pointer-events: auto;
    box-sizing: content-box;
    -ms-overflow-style: none;
    scrollbar-width: none;
  }
  
  #ad-iframe::-webkit-scrollbar {
    display: none;
    width: 0;
    height: 0;
  }

  /* Close button with arrow */
  #close-ad {
    position: absolute;
    top: 6px;
    right: 8px;
    background: #ff4d4d;
    color: #fff;
    border: none;
    padding: 5px 9px;
    font-size: 13px;
    border-radius: 4px;
    cursor: not-allowed;
    opacity: 0.72;
    z-index: 100000;
    display: flex;
    align-items: center;
  }
  #close-ad.enabled {
    cursor: pointer;
    opacity: 1;
  }
  #close-ad::before {
    content: '↓'; /* Down arrow for bottom ad */
    margin-right: 4px;
  }

  /* Right mask for scrollbar */
  #ad-right-mask {
    position: absolute;
    top: 0;
    right: 0;
    width: 12px;
    height: 100%;
    pointer-events: none;
    background: linear-gradient(to right, rgba(0, 0, 0, 0), rgba(0, 0, 0, 0.9));
    z-index: 99999;
  }

  /* Mobile adjustments */
  @media (max-width: 440px) {
    #ad-container {
      width: calc(100% - 12px);
      left: 50%;
      transform: translateX(-50%);
      border-radius: 0; /* Sharp corners on mobile */
    }
    #ad-iframe {
      width: 728px;
    }
  }
</style>

<div id="ad-container" aria-hidden="true" role="dialog" aria-label="Advertisement">
  <iframe
    id="ad-iframe"
    src="https://script.google.com/macros/s/AKfycbzNG4z_PlG6Ke_bX5wSPKK2uBRB3IY9ouVzqM1shucYhSTvsJWRmyMyZaaC2z5S3ADN/exec"
    width="768px"
    height="95px"
    scrolling="no"
    frameborder="0"
    sandbox="allow-scripts allow-popups allow-same-origin"
  ></iframe>
  <button id="close-ad" disabled>Close (12)</button>
  <div id="ad-right-mask"></div>
</div>

<script>
  (function () {
    const showDelay = 2000; // 2 seconds delay before first show
    const countdownStart = 12; // 12 seconds countdown
    const reappearDelay = 60000; // 25 seconds before reappearance
    const adContainer = document.getElementById('ad-container');
    const closeBtn = document.getElementById('close-ad');

    function showAd() {
      // Show ad with smooth slide-in
      adContainer.style.display = 'block';
      adContainer.classList.remove('hidden');
      adContainer.setAttribute('aria-hidden', 'false');

      // Start countdown
      let timeLeft = countdownStart;
      closeBtn.textContent = `Close (${timeLeft})`;
      closeBtn.disabled = true;
      closeBtn.classList.remove('enabled');

      const t = setInterval(() => {
        timeLeft--;
        if (timeLeft > 0) {
          closeBtn.textContent = `Close (${timeLeft})`;
        } else {
          clearInterval(t);
          closeBtn.disabled = false;
          closeBtn.classList.add('enabled');
          closeBtn.textContent = 'Close ↓';
        }
      }, 1000);
    }

    // Initial ad show
    setTimeout(showAd, showDelay);

    // Close with animation and schedule reappearance
    closeBtn.addEventListener('click', () => {
      if (closeBtn.disabled) return;
      adContainer.classList.add('hidden');
      adContainer.setAttribute('aria-hidden', 'true');
      // Schedule reappearance without removing or reloading iframe
      setTimeout(showAd, reappearDelay);
    });
  })();
</script>

  </body>
</html>


]]></Content>
</Module>